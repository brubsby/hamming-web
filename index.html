<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hamming Graph Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            margin: 0;
            background-color: #1e1e1e; /* Dark background like Obsidian */
            color: #ccc;
            font-family: sans-serif;
            overflow: hidden;
        }
        svg {
            width: 100vw;
            height: 100vh;
        }
        .node circle {
            stroke: #fff;
            stroke-width: 1.5px;
            fill: #69b3a2;
        }
        .node text {
            pointer-events: none;
            font-size: 12px;
            fill: #eee;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 1px;
            marker-end: url(#arrow);
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #fff;
        }
        .controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(30, 30, 30, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #444;
            z-index: 100;
        }
        .control-group {
            margin-bottom: 10px;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }
        .control-group input {
            width: 150px;
        }
    </style>
</head>
<body>
    <div id="loading">Loading graph data...</div>
    
    <div class="controls">
        <div class="control-group">
            <label for="linkDistance">Link Distance: <span id="linkDistanceVal">50</span></label>
            <input type="range" id="linkDistance" min="10" max="200" value="50">
        </div>
        <div class="control-group">
            <label for="chargeStrength">Charge Strength: <span id="chargeStrengthVal">-300</span></label>
            <input type="range" id="chargeStrength" min="-1000" max="0" value="-300">
        </div>
        <div class="control-group">
            <label for="collisionRadius">Collision Radius: <span id="collisionRadiusVal">10</span></label>
            <input type="range" id="collisionRadius" min="0" max="50" value="10">
        </div>
    </div>

    <svg>
        <defs>
            <marker id="arrow" viewBox="0 -5 10 10" refX="15" refY="0" markerWidth="6" markerHeight="6" orient="auto">
                <path d="M0,-5L10,0L0,5" fill="#999"></path>
            </marker>
        </defs>
    </svg>

    <script>
        // Configuration
        const DATA_FILE = 'graph.json';
        const NODE_RADIUS = 5;
        let LINK_DISTANCE = 50;

        // Setup SVG and Dimensions
        const svg = d3.select("svg");
        const width = window.innerWidth;
        const height = window.innerHeight;

        // Zoom behavior
        const g = svg.append("g");
        const zoom = d3.zoom()
            .scaleExtent([0.1, 10])
            .on("zoom", (event) => {
                g.attr("transform", event.transform);
            });
        svg.call(zoom);

        // UI Controls
        const linkDistanceInput = document.getElementById('linkDistance');
        const chargeStrengthInput = document.getElementById('chargeStrength');
        const collisionRadiusInput = document.getElementById('collisionRadius');
        
        const linkDistanceVal = document.getElementById('linkDistanceVal');
        const chargeStrengthVal = document.getElementById('chargeStrengthVal');
        const collisionRadiusVal = document.getElementById('collisionRadiusVal');

        // Load Data
        d3.json(DATA_FILE + "?t=" + Date.now()).then(data => {
            document.getElementById('loading').style.display = 'none';

            const links = data.links || data.edges;

            // Initialize Simulation
            const simulation = d3.forceSimulation(data.nodes)
                .force("link", d3.forceLink(links).id(d => d.id).distance(LINK_DISTANCE))
                .force("charge", d3.forceManyBody().strength(-300))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("collide", d3.forceCollide(NODE_RADIUS * 2));

            // Control Listeners
            linkDistanceInput.addEventListener('input', (e) => {
                const val = +e.target.value;
                linkDistanceVal.innerText = val;
                simulation.force("link").distance(val);
                simulation.alpha(1).restart();
            });

            chargeStrengthInput.addEventListener('input', (e) => {
                const val = +e.target.value;
                chargeStrengthVal.innerText = val;
                simulation.force("charge").strength(val);
                simulation.alpha(1).restart();
            });

            collisionRadiusInput.addEventListener('input', (e) => {
                const val = +e.target.value;
                collisionRadiusVal.innerText = val;
                simulation.force("collide").radius(val);
                simulation.alpha(1).restart();
            });

            // Create Links
            const link = g.append("g")
                .attr("class", "links")
                .selectAll("line")
                .data(links)
                .join("line")
                .attr("class", "link");

            // Create Nodes
            const node = g.append("g")
                .attr("class", "nodes")
                .selectAll("g")
                .data(data.nodes, d => d.id) // Key function is important for updates
                .join("g")
                .attr("class", "node")
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended))
                .on("contextmenu", (event, d) => {
                    event.preventDefault();
                    deleteSubtree(d);
                });

            node.append("circle")
                .attr("r", NODE_RADIUS);

            node.append("text")
                .attr("dx", 8)
                .attr("dy", ".35em")
                .text(d => d.id);

            // Simulation Tick
            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("transform", d => `translate(${d.x},${d.y})`);
            });

            function deleteSubtree(rootNode) {
                const nodesToRemove = new Set([rootNode.id]);
                const queue = [rootNode.id];
                
                // Build adjacency list for children (source -> target)
                const childrenMap = new Map();
                links.forEach(l => {
                    // d3.forceLink replaces ids with object references, so we check both
                    const sourceId = l.source.id || l.source;
                    const targetId = l.target.id || l.target;
                    
                    if (!childrenMap.has(sourceId)) childrenMap.set(sourceId, []);
                    childrenMap.get(sourceId).push(targetId);
                });

                // BFS to find all descendants
                while (queue.length > 0) {
                    const currentId = queue.shift();
                    if (childrenMap.has(currentId)) {
                        const children = childrenMap.get(currentId);
                        children.forEach(childId => {
                            if (!nodesToRemove.has(childId)) {
                                nodesToRemove.add(childId);
                                queue.push(childId);
                            }
                        });
                    }
                }

                // Filter nodes
                data.nodes = data.nodes.filter(n => !nodesToRemove.has(n.id));
                
                // Filter links (remove if source OR target is removed)
                // We must update the 'links' variable which is used by the simulation
                const linksToKeep = links.filter(l => {
                    const sourceId = l.source.id || l.source;
                    const targetId = l.target.id || l.target;
                    return !nodesToRemove.has(sourceId) && !nodesToRemove.has(targetId);
                });
                
                // Update the data reference (if links was a separate var, update it)
                // In this scope, 'links' was const, so we might need to modify the array in place or handle the update carefully.
                // Since 'links' is a const reference to 'data.links' (or edges), let's re-assign to data.links/edges and update simulation.
                // Actually, let's just update the array the simulation uses.
                
                // Simplest way: modify the arrays in place or re-assign if possible. 
                // Since we can't reassign const 'links', let's update data.links/edges and re-run the join.
                
                if (data.links) data.links = linksToKeep;
                if (data.edges) data.edges = linksToKeep;
                
                updateGraph(data.nodes, linksToKeep);
            }

            function updateGraph(newNodes, newLinks) {
                // Update nodes
                const nodeSelection = g.select(".nodes").selectAll(".node")
                    .data(newNodes, d => d.id);
                
                nodeSelection.exit().remove();

                // Update links
                const linkSelection = g.select(".links").selectAll(".link")
                    .data(newLinks, d => d.id ? d.id : (d.source.id + "-" + d.target.id)); // Use a key for links too

                linkSelection.exit().remove();

                // Restart simulation with new data
                simulation.nodes(newNodes);
                simulation.force("link").links(newLinks);
                simulation.alpha(1).restart();
            }

            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }

            // Handle window resize
            window.addEventListener('resize', () => {
                const newWidth = window.innerWidth;
                const newHeight = window.innerHeight;
                
                svg.attr("width", newWidth).attr("height", newHeight);
                simulation.force("center", d3.forceCenter(newWidth / 2, newHeight / 2));
                simulation.alpha(1).restart();
            });
        }).catch(error => {
            console.error("Error loading the data:", error);
            document.getElementById('loading').innerText = "Error loading 'graph.json'. Make sure to generate it first.";
        });
    </script>
</body>
</html>
